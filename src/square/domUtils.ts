/**\n * Square DOM Utilities for reliable browser automation\n * Provides robust DOM interaction methods with error handling and retries\n */\n\nexport interface InteractionResult {\n  success: boolean;\n  element?: Element;\n  error?: string;\n  duration?: number;\n}\n\nexport interface FindElementOptions {\n  timeout?: number;\n  retries?: number;\n  visible?: boolean;\n  enabled?: boolean;\n}\n\nexport interface TypeOptions extends FindElementOptions {\n  clear?: boolean;\n  delay?: number;\n}\n\nexport interface ExtractTextResult {\n  success: boolean;\n  text?: string;\n  error?: string;\n}\n\n/**\n * Main SquareDOMUtils class for DOM automation\n */\nexport class SquareDOMUtils {\n  private static readonly DEFAULT_TIMEOUT = 5000;\n  private static readonly DEFAULT_RETRIES = 2;\n  private static readonly DEFAULT_DELAY = 100;\n\n  /**\n   * Find element with robust error handling and retries\n   */\n  static async findElement(\n    selector: string, \n    options: FindElementOptions = {}\n  ): Promise<InteractionResult> {\n    const startTime = Date.now();\n    const { \n      timeout = this.DEFAULT_TIMEOUT, \n      retries = this.DEFAULT_RETRIES,\n      visible = true,\n      enabled = true \n    } = options;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        const element = await this.waitForElement(selector, timeout / (retries + 1));\n        \n        if (!element) {\n          if (attempt === retries) {\n            return {\n              success: false,\n              error: `Element not found: ${selector}`,\n              duration: Date.now() - startTime\n            };\n          }\n          continue;\n        }\n\n        // Check visibility if required\n        if (visible && !this.isElementVisible(element)) {\n          if (attempt === retries) {\n            return {\n              success: false,\n              error: `Element not visible: ${selector}`,\n              duration: Date.now() - startTime\n            };\n          }\n          continue;\n        }\n\n        // Check if enabled if required\n        if (enabled && this.isElementDisabled(element)) {\n          if (attempt === retries) {\n            return {\n              success: false,\n              error: `Element disabled: ${selector}`,\n              duration: Date.now() - startTime\n            };\n          }\n          continue;\n        }\n\n        return {\n          success: true,\n          element,\n          duration: Date.now() - startTime\n        };\n\n      } catch (error) {\n        if (attempt === retries) {\n          return {\n            success: false,\n            error: `Find element failed: ${error instanceof Error ? error.message : String(error)}`,\n            duration: Date.now() - startTime\n          };\n        }\n        await this.delay(this.DEFAULT_DELAY * (attempt + 1));\n      }\n    }\n\n    return {\n      success: false,\n      error: `Element search failed after ${retries + 1} attempts`,\n      duration: Date.now() - startTime\n    };\n  }\n\n  /**\n   * Safe click with validation and error handling\n   */\n  static async safeClick(\n    selector: string, \n    options: FindElementOptions = {}\n  ): Promise<InteractionResult> {\n    const findResult = await this.findElement(selector, options);\n    \n    if (!findResult.success || !findResult.element) {\n      return findResult;\n    }\n\n    const startTime = Date.now();\n    \n    try {\n      const element = findResult.element as HTMLElement;\n      \n      // Scroll element into view\n      element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      await this.delay(200);\n\n      // Click the element\n      element.click();\n      \n      // Wait for any potential navigation or state changes\n      await this.delay(300);\n\n      return {\n        success: true,\n        element,\n        duration: Date.now() - startTime\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: `Click failed: ${error instanceof Error ? error.message : String(error)}`,\n        duration: Date.now() - startTime\n      };\n    }\n  }\n\n  /**\n   * Safe typing with clearing and validation\n   */\n  static async safeType(\n    selector: string, \n    text: string, \n    options: TypeOptions = {}\n  ): Promise<InteractionResult> {\n    const findResult = await this.findElement(selector, options);\n    \n    if (!findResult.success || !findResult.element) {\n      return findResult;\n    }\n\n    const startTime = Date.now();\n    const { clear = false, delay = 50 } = options;\n    \n    try {\n      const element = findResult.element as HTMLInputElement | HTMLTextAreaElement;\n      \n      // Focus the element\n      element.focus();\n      await this.delay(100);\n\n      // Clear existing text if requested\n      if (clear) {\n        element.select();\n        await this.delay(50);\n      }\n\n      // Type the text character by character for more realistic input\n      for (const char of text) {\n        element.value += char;\n        \n        // Trigger input events\n        element.dispatchEvent(new Event('input', { bubbles: true }));\n        element.dispatchEvent(new Event('change', { bubbles: true }));\n        \n        if (delay > 0) {\n          await this.delay(delay);\n        }\n      }\n\n      // Final change event\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n      element.dispatchEvent(new Event('blur', { bubbles: true }));\n\n      return {\n        success: true,\n        element,\n        duration: Date.now() - startTime\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: `Type failed: ${error instanceof Error ? error.message : String(error)}`,\n        duration: Date.now() - startTime\n      };\n    }\n  }\n\n  /**\n   * Extract text from element\n   */\n  static async extractText(selector: string): Promise<ExtractTextResult> {\n    try {\n      const findResult = await this.findElement(selector, { visible: false });\n      \n      if (!findResult.success || !findResult.element) {\n        return {\n          success: false,\n          error: findResult.error || 'Element not found'\n        };\n      }\n\n      const text = findResult.element.textContent?.trim() || '';\n      \n      return {\n        success: true,\n        text\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: `Extract text failed: ${error instanceof Error ? error.message : String(error)}`\n      };\n    }\n  }\n\n  /**\n   * Wait for element to appear in DOM\n   */\n  static async waitForElement(\n    selector: string, \n    timeout: number = this.DEFAULT_TIMEOUT\n  ): Promise<Element | null> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n      \n      const checkElement = () => {\n        const element = document.querySelector(selector);\n        \n        if (element) {\n          resolve(element);\n          return;\n        }\n        \n        if (Date.now() - startTime >= timeout) {\n          resolve(null);\n          return;\n        }\n        \n        setTimeout(checkElement, 100);\n      };\n      \n      checkElement();\n    });\n  }\n\n  /**\n   * Wait for page load to complete\n   */\n  static async waitForPageLoad(timeout: number = 10000): Promise<boolean> {\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n      \n      const checkLoad = () => {\n        if (document.readyState === 'complete') {\n          resolve(true);\n          return;\n        }\n        \n        if (Date.now() - startTime >= timeout) {\n          resolve(false);\n          return;\n        }\n        \n        setTimeout(checkLoad, 100);\n      };\n      \n      if (document.readyState === 'complete') {\n        resolve(true);\n      } else {\n        checkLoad();\n      }\n    });\n  }\n\n  /**\n   * Check if element is visible\n   */\n  static isElementVisible(element: Element): boolean {\n    if (!element) return false;\n    \n    const style = window.getComputedStyle(element);\n    return (\n      style.display !== 'none' &&\n      style.visibility !== 'hidden' &&\n      style.opacity !== '0' &&\n      element.offsetWidth > 0 &&\n      element.offsetHeight > 0\n    );\n  }\n\n  /**\n   * Check if element is disabled\n   */\n  static isElementDisabled(element: Element): boolean {\n    if (element instanceof HTMLInputElement || \n        element instanceof HTMLButtonElement || \n        element instanceof HTMLSelectElement ||\n        element instanceof HTMLTextAreaElement) {\n      return element.disabled;\n    }\n    \n    return element.getAttribute('disabled') !== null ||\n           element.getAttribute('aria-disabled') === 'true';\n  }\n\n  /**\n   * Simple delay utility\n   */\n  static async delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Take screenshot for debugging (Chrome extension API)\n   */\n  static async takeScreenshot(): Promise<string | null> {\n    try {\n      // Use Chrome extension API if available\n      if (typeof chrome !== 'undefined' && chrome.tabs && chrome.tabs.captureVisibleTab) {\n        return new Promise((resolve) => {\n          chrome.tabs.captureVisibleTab(undefined, { format: 'png' }, (dataUrl) => {\n            resolve(dataUrl || null);\n          });\n        });\n      }\n      \n      // Fallback for content script context\n      return null;\n    } catch (error) {\n      console.warn('Screenshot failed:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get all elements matching selector\n   */\n  static async getAllElements(selector: string): Promise<Element[]> {\n    try {\n      return Array.from(document.querySelectorAll(selector));\n    } catch (error) {\n      console.warn(`Get all elements failed for ${selector}:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Get element value (for inputs)\n   */\n  static async getElementValue(element: Element | string): Promise<string> {\n    try {\n      let targetElement: Element | null;\n      \n      if (typeof element === 'string') {\n        const findResult = await this.findElement(element);\n        targetElement = findResult.element || null;\n      } else {\n        targetElement = element;\n      }\n      \n      if (!targetElement) {\n        return '';\n      }\n      \n      if (targetElement instanceof HTMLInputElement || \n          targetElement instanceof HTMLTextAreaElement) {\n        return targetElement.value;\n      }\n      \n      return targetElement.textContent?.trim() || '';\n    } catch (error) {\n      console.warn('Get element value failed:', error);\n      return '';\n    }\n  }\n\n  /**\n   * Clear and type in element\n   */\n  async clearAndType(element: Element, text: string): Promise<void> {\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n      element.focus();\n      element.select();\n      element.value = text;\n      \n      // Trigger events\n      element.dispatchEvent(new Event('input', { bubbles: true }));\n      element.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n\n  /**\n   * Wait utility\n   */\n  async wait(ms: number): Promise<void> {\n    return SquareDOMUtils.delay(ms);\n  }\n\n  /**\n   * Get element by selector\n   */\n  async getElement(selector: string): Promise<Element | null> {\n    const result = await SquareDOMUtils.findElement(selector);\n    return result.element || null;\n  }\n\n  /**\n   * Safe click wrapper for instance method\n   */\n  async safeClick(element: Element | string): Promise<void> {\n    if (typeof element === 'string') {\n      await SquareDOMUtils.safeClick(element);\n    } else if (element instanceof HTMLElement) {\n      element.click();\n    }\n  }\n\n  /**\n   * Wait for element wrapper for instance method\n   */\n  async waitForElement(selector: string, timeout?: number): Promise<Element | null> {\n    return SquareDOMUtils.waitForElement(selector, timeout);\n  }\n\n  /**\n   * Get all elements wrapper for instance method\n   */\n  async getAllElements(selector: string): Promise<Element[]> {\n    return SquareDOMUtils.getAllElements(selector);\n  }\n\n  /**\n   * Navigate to page (for inheritance)\n   */\n  async navigateToPage(url: string): Promise<void> {\n    if (window.location.href !== url) {\n      window.location.href = url;\n      await this.wait(2000);\n    }\n  }\n\n  /**\n   * Capture screenshot wrapper\n   */\n  async captureScreenshot(name?: string): Promise<string | null> {\n    return SquareDOMUtils.takeScreenshot();\n  }\n\n  /**\n   * Logging methods for inheritance\n   */\n  protected log(message: string): void {\n    console.log(`[SquareDOMUtils] ${message}`);\n  }\n\n  protected logError(message: string, error: any): void {\n    console.error(`[SquareDOMUtils] ${message}:`, error);\n  }\n}
